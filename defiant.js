// @ts-nocheck
"use strict";
/** Defiant * @version 1.0.0 * @see https://github.com/Serrin/ * @license MIT */
const Tuple=(...values)=>Object.freeze(values);Tuple.of=(...values)=>Tuple(...values);Tuple.from=(iterable)=>Tuple(...Array.from(iterable));Tuple.isTuple=(value)=>Array.isArray(value)&&Object.isFrozen(value);Tuple.isEqual=function(x,y){const _isObject=(value)=>value!=null&&typeof value==="object";function _isEqual(x,y){if(x===y||(Number.isNaN(x)&&Number.isNaN(y))){return true;}if(Array.isArray(x)&&Array.isArray(y)){if(x.length!==y.length){return false;}if(x.length===0){return true;}for(let i=0;i<x.length;i++){if(!_isEqual(x[i],y[i])){return false;}}return true;}if(_isObject(x)&&_isObject(y)){if(Object.getPrototypeOf(x)!==Object.getPrototypeOf(y)){return false;}const xKeys=Object.keys(x);const yKeys=Object.keys(y);if(xKeys.length!==yKeys.length){return false;}if(xKeys.length===0){return true;}for(let key of xKeys){if(!yKeys.includes(key)||!_isEqual(x[key],y[key])){return false;}}return true;}return false;}return _isEqual(x,y);};Tuple.toArray=(value)=>Array.from(value);const Record=(O)=>Object.freeze(Object.assign({},O));Record.fromEntries=(entries)=>Object.freeze(Object.fromEntries(entries));Record.fromObject=(O)=>Record(O);Record.isRecord=(value)=>value!=null&&typeof value==="object"&&Object.isFrozen(value);Record.isEqual=Tuple.isEqual;Record.toObject=(value)=>Object.assign({},value);export{Tuple,Record};export default{Tuple,Record};